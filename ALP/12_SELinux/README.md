## Практика с SELinux

**1. Запустить nginx на нестандартном порту 3-мя разными способами:**
<li> переключатели setsebool;</li>
<li> добавление нестандартного порта в имеющийся тип;</li>
<li> формирование и установка модуля SELinux.</li><br>
К сдаче:<br>
README с описанием каждого решения (скриншоты и демонстрация приветствуются).<br><br>

**2. Обеспечить работоспособность приложения при включенном selinux.**
<li> развернуть приложенный стенд https://github.com/mbfx/otus-linux-adm/tree/master/selinux_dns_problems</li> 
<li> выяснить причину неработоспособности механизма обновления зоны (см. README);</li>
<li> предложить решение (или решения) для данной проблемы;</li>
<li> выбрать одно из решений для реализации, предварительно обосновав выбор;</li>
<li> реализовать выбранное решение и продемонстрировать его работоспособность.</li><br>
К сдаче:<br>
<li> README с анализом причины неработоспособности, возможными способами решения и обоснованием выбора одного из них;</li>
<li> исправленный стенд или демонстрация работоспособной системы скриншотами и описанием.</li><br><br>

**Решение:** <br>
1. Запустить nginx на нестандартном порту 3-мя разными способами<br>
Запускаем vagrant стенд с уже настроенным провижином nginx на нестандартный порт 4881. После запуска стенда убедимся, что SELinux включен, а nginx отказался запускаться на нестандартном порту
![Проверяем статус selinux и состояние Nginx](./se_nginx_status.jpg)<br>
<li> переключатели setsebool</li>
Для начала доустановим пакет <em>policycoreutils-python</em> и скормим ему audit лог. Приложение предлагает рекомендует нам воспользоваться переключателем setsebool.

![audit2why для nginx](./se_nginx_status.jpg)<br>
Не будем спорить и воспользуемся им. После этого вновь попробуем запустить nginx

![Меняем переключатель и проверяем nginx](./1nginx_started.jpg)<br>
Nginx жив, здоров. Откатываем изменения и идем дальше<br>

<li> Добавление нестандартного порта в имеющийся тип </li>
Проверяем, что наш nginx по-прежнему себя плохо чувствует

![Проверяем состояние nginx](./2nginx_error.jpg)<br>
Теперь пойдем по пути добавления нестандартного порта в список доступных для службы. Для этого вопспользуемся услуга semanage и проверим какие порты доступны на текущий момент

![semanage активные порты](./semanage_status.jpg)<br>
Как мы видим портов всяких разных полно, но нашего 4881 нет и в помине. Добавим же его

![Добавляем порт](./2nginx_error.jpg)<br>
Проверяем, что порт добавлен и пробуем запустить nginx.

![Проверяем состояние nginx](./2nginx_started.jpg)<br>
Nginx жив, здоров. Откатываем изменения и идем дальше<br>

<li> формирование и установка модуля SELinux.</li>
Проверяем, что наш nginx по-прежнему себя плохо чувствует

![Проверяем состояние nginx](./3nginx_error.jpg)<br>
Для формирования модуля SELinux воспользуемся утилитой audit2allow, скормив ему наш выдуржку аудит лога, относящуюся к nginx, и вежливо попросив собрать на его основании модуль с названием nginx

![ФОрмируем модуль для audit2allow](./audit2allow_nginx.jpg)<br>
Применим собранный модуль и проверим как на этот раз чувствует себя nginx

![Проверяем состояние nginx](./3nginx_started.jpg)<br>
Nginx жив, здоров. Три способа рассмотрены.<br><br>

2. Обеспечить работоспособность приложения при включенном selinux<br>
Запускаем проблемный vagrant стенд (настройка стенда осуществляется через , состоящий из DNS сервера ns01 и клиентской машины client. Воспроизведем действия инженера по внесению изменений в зону

![Пробуем обновить зону](./try_update.jpg)<br>
Видим, что обновление заканчивается ошибкой. Перейдем к разбору проблем с SELinux. Посмотрим на audit логи клиентской машины

![Смотрим логи клиента](./search_problems_client.jpg)<br>
И ничего не находим, чтобы относилось к нашей задаче по обновлению зоны. Пойдем с тем же вопрос на сам DNS сервер.

![Смотрим логи сервера](./search_problems_ns01.jpg)<br>
И здесь мы уже можем наблюдать проблему. А именно несоответствие контекстов безопасности домена. Это говорит о том, что конфиги мы складываем в каталог, у которого по умолчанию не настроено для этого правило.
Посмотрим какие контексты безопасности у нас есть для /etc/named.

![Смотрим логи сервера](./context_named_all.jpg)<br>
 Как мы видим, все они имеют контекст etc_t вместо ожидаемых named_t. <br>
 В своем решении пойдем по пути изменения контекста безопасности, раз мы считаем, что файлы должны лежать там
 
 ![Смотрим логи сервера](./Changed_context.jpg)<br>
 
 Пробуем еще раз обновить зону И проверим полученный результат
 
 ![Пробуем обновить зону](./retry_update.jpg)<br>